import pandas as pd
import argparse
import csv
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import os
import sys

def par():

    parser = argparse.ArgumentParser(prog="recomb_rates.py")
    parser.add_argument("-t","--txt",dest="txt",help="TSV file containing merged blocks generated by recombreduce.py",default=None)
    parser.add_argument("-t2","--txt2",dest="txt2",help="TSV file containing blocks generated by recombmapper.py",default=None)
    parser.add_argument("-v","--vcf",dest="vcf",help="Filtered VCF file for SNP density",default=None)
    parser.add_argument("-b","--bins",dest="bin",help="Number of bins for plotting recombination rates and/or SNP density. Default = 100.",default=100,type=int,choices=range(25,100000),metavar="{25..100000}")
    parser.add_argument("-s","--sets",dest="sets",help="Sets file containing individual grouping",default=None)
    parser.add_argument("-c","--centromeres",dest="cent",help="TSV file containing centromere locations",default=None)
    parser.add_argument("-m","--missing",dest="miss",help="TSV file containing missingness (from allele_blocks.py)",default=None)
    parser.add_argument("-n","--numsnps",dest="numsnps",help="Minimum number of SNPs required to define a block. Default = 2.",default=2,type=int,choices=range(2,1000),metavar="{2..1000}")
    parser.add_argument("-l","--length",dest="length",help="Minimum length (bp) required to define a block. Default = 1000.",default=1000,type=int,choices=range(1000,10000000),metavar="{1000..10000000}")
    parser.add_argument("-pb","--plotbar",dest="plotbar",help="Plot bargraphs",default=False,action='store_true')
    parser.add_argument("-pr","--plotrecomb",dest="plotrecomb",help="Plot recombination rates",default=False,action='store_true')
    parser.add_argument("-o","--outfolder",dest="outfolder",help="Folder name for output",default='recomboutput')
    args = parser.parse_args()

    if args.vcf is not None:
        invcf = args.vcf
        print("\n\tInput VCF: ",invcf)
    else:
        invcf = None

    incent = args.cent
    inmiss = args.miss

    outfolder = args.outfolder
    outfolder = outfolder+"/3.recomb_rates/"
    print("\tOutput folder: ",outfolder)

    if not os.path.isdir(outfolder):
        os.makedirs(outfolder)

    if args.sets is not None:
        insets = args.sets
        print("\tInput sets: ",insets)
    if args.sets is None:
        sets_directory = os.path.join(args.outfolder,'0.cluster')
        if os.path.exists(sets_directory):
            for file in os.listdir(sets_directory):
                if file.endswith('_sets.txt'):
                    insets = os.path.join(sets_directory,file)
                    print("\tInput sets: ",insets)
    else:
        insets = None

    if args.txt is not None:
        reducedblocks = args.txt
        print("\tMerged blocks: ",reducedblocks)
    elif args.txt is None:
        dir2 = os.path.join(args.outfolder,'2.merge_blocks')
        if os.path.exists(dir2):
            for file in os.listdir(dir2):
                if file.endswith('_blocks_merged.txt'):
                    reducedblocks = os.path.join(dir2,file)
                    print("\tMerged blocks: ",reducedblocks)
    else:
        reducedblocks = None

    if args.txt2 is not None:
        unmergedblocks = args.txt2
        print("\tUnmerged blocks: ",unmergedblocks)
    elif args.txt2 is None:
        dir1 = os.path.join(args.outfolder,'1.allele_blocks')
        for file in os.listdir(dir1):
            if file.endswith('_blocks.txt'):
                unmergedblocks = os.path.join(dir1,file)
                print("\tUnmerged blocks: ",unmergedblocks)
    else:
        unmergedblocks = None

    recombdata = pd.read_csv(reducedblocks, sep='\t')
    recd2 = recombdata[['Chr','Sample','Allele','Start pos','End pos','Length','Num SNPs']]
    numindv = len(recd2['Sample'].unique())

    chroms = recd2.Chr.unique()
    illegal = ["Pan_BP_CH","chrUn"]
    chr2 = []
    for chr in chroms:
        if chr in illegal:
            continue
        else:
            chr2.append(chr)

    if reducedblocks is not None:
        intxt = reducedblocks
    elif unmergedblocks is not None:
        intxt = unmergedblocks
    else:
        print("\tError: no blocks file found.")
        sys.exit(1)

    if unmergedblocks is not None:
        recombdata2 = pd.read_csv(unmergedblocks, sep='\t')
        recd23 = recombdata2[['Chr','Sample','Allele','Start pos','End pos','Length','Num SNPs']]

    if incent is not None:
        centromeres = pd.read_csv(incent, sep='\t')
        print("\tCentromeres: ",incent)
    else:
        centromeres = None

    ordered_individuals = None
    if insets is not None:
        sets = pd.read_csv(insets, sep='\t',header=None,names=['Individual','Group'])
        ordered_individuals = sets['Individual'].tolist()

    if args.plotbar is True:
        print("\n\tPlotting blocks:")
        print("\tMerged:")
        bargraph(recd2, reducedblocks, chr2, outfolder, args.length, args.numsnps, ordered_individuals)
        print("\tUnmerged:")
        bargraph(recd23, unmergedblocks, chr2, outfolder, args.length, args.numsnps, ordered_individuals)

    alldata = []
    print("\n\tCalculating recombination rates\n\tGroup:")

    if insets is not None:
        setsdict = {}
        for i in sets['Group'].unique():
            setsdict[i] = [sets['Individual'][j] for j in sets[sets['Group']==i].index]
        groups = []
        for key, value in setsdict.items():
            if len([item for item in value if item]) > 30:
                groups.append(key)

        for group in groups:
            recd3 = recd2
            groupeddataframe = recd3.loc[recd3['Sample'].isin(setsdict[group])]
            rr = recombrate(groupeddataframe, intxt, chr2, group, len(setsdict[group]), outfolder, args.bin, args.numsnps, args.length)
            for row in rr:
                alldata.append(row)

    if reducedblocks is not None:
        group='merged'
        rr = recombrate(recd2, reducedblocks, chr2, group, numindv, outfolder, args.bin, args.numsnps, args.length)
        for row in rr:
            alldata.append(row)

    if unmergedblocks is not None:
        group='unmerged'
        rr2 = recombrate(recd23, unmergedblocks, chr2, group, numindv, outfolder, args.bin, args.numsnps, args.length)
        for row in rr2:
            alldata.append(row)

    if invcf is not None:
        density = snpdensity(invcf, chr2, reducedblocks, outfolder, args.bin)
        density2 = pd.DataFrame(density, columns = ["Chr","Start","End","SNP Density"])
    else:
        density2 = None

    if args.plotrecomb is True:
        alldata2 = pd.DataFrame(alldata, columns = ["Group","Chr","Start","End","Recombination Rate"])
        if inmiss is not None:
            missing = pd.read_csv(inmiss, sep='\t')
        else:
            missing = None
        frequgraph(alldata2, reducedblocks, chr2, outfolder, args.numsnps, args.length, centromeres, density2, missing)

    print("\nrecomb_rates.py finished.\n")


def bargraph(recd2, intxt, chr2, outfolder, length, numsnps, ordered_individuals=None):

    #takes unique individual names from df
    if ordered_individuals is None:
        ordered_individuals = recd2.Sample.unique()

    nrows = len(chr2)
    ysize = nrows*4.4

    fig, ax = plt.subplots(figsize = (7, ysize), sharex='col', sharey='row')
    plt.axis('off')
    fig.tight_layout()

    n=1
    for chr in chr2:
        recd22 = recd2[recd2['Chr'] == chr]
        recd22 = recd22[recd22['Length'] >= length]
        recd22 = recd22[recd22['Num SNPs'] >= numsnps]
        ax2 = fig.add_subplot(nrows,1,n)
        y=0.75
        for samp in ordered_individuals:
            recd2_samp = recd22[recd22['Sample'] == samp]
            zerodf = recd2_samp[recd2_samp['Allele']==0]
            zerolist = [tuple(r) for r in zerodf[['Start pos', 'Length']].to_numpy()]
            onedf = recd2_samp[recd2_samp['Allele']==1]
            onelist = [tuple(r) for r in onedf[['Start pos', 'Length']].to_numpy()]
            y+=1
            ylist = (y,0.5)
            ax2.broken_barh(zerolist, ylist, facecolors ='blue')
            ax2.broken_barh(onelist, ylist, facecolors ='red')
        ax2.tick_params(axis='y',labelsize=7)
        ax2.tick_params(axis='x',labelsize=7)
        ax2.xaxis.offsetText.set_fontsize(7)
        ax2.plot()
        if n <= 7:
            plt.ylabel('Individuals',size=8)
        if n % 7 == 0:
            plt.xlabel('Position',size=8)
        ax2.set_title(chr,fontsize=9)
        print("\t",chr,' done')
        n+=1

    outfile = os.path.join(outfolder,os.path.basename(intxt)[:-4]+"_bargraph.png")
    plt.tight_layout(h_pad=0.1)
    plt.savefig(outfile, dpi=600,bbox_inches='tight')
    print("\tSaved as",outfile,"\n")


def recombrate(recd2, intxt, chrs, label, numindv, outfolder, bin, numsnps, length):

    recombrates = []

    for chr in chrs:
        recd22 = recd2[recd2['Chr'] == chr]
        recd22 = recd22[recd22['Length'] >= length]
        recd22 = recd22[recd22['Num SNPs'] >= numsnps]
        positions = recd22['Start pos'].tolist()
        positions2 = recd22['End pos'].tolist()
        positions.extend(positions2)
        positions.sort()
        bin2 = positions[-1]
        bin3 = int(round(bin2/bin,0))

        #count number of COs in each bin
        x = 0
        countlistx = []
        countlisty = []
        count = 0
        for pos in positions:
            if x*bin3 <= pos < (x+1)*bin3:
                count+=1
                continue
            else:
                rate = count/bin3/numindv
                countlisty.append(rate)
                start = int((x)*bin3)
                end = int((x+1)*bin3)
                countlistx.append((start+end)/2)
                recombrates.append([label,chr,start,end,rate])
                x+=1
                count = 0

    #save txt file
    outfile3 = os.path.join(outfolder,os.path.basename(intxt)[:-4]+"_group_"+str(label)+"_recombinationrate.txt")
    head = ["Group","Chr","Start","End","Recombination Rate"]
    with open(outfile3,'w+') as out_rr:
        writer = csv.writer(out_rr, delimiter="\t")
        writer.writerow(head)
        for row in recombrates:
            writer.writerow(row)
    out_rr.close()

    print("\t",label," done:",outfile3)

    return recombrates

def snpdensity(invcf, chr2, intxt, outfolder, bin4):

    print("\n\tCalculating SNP Density")

    pos = pd.read_csv(invcf,sep='\t',comment='#',usecols = [0,1], names = ['Chr','Positions'])

    density = []

    for chr in chr2:
        positions = pos[pos['Chr'] == chr]
        bin = positions['Positions'].tolist()
        bin2 = bin[-1]
        bin3 = int(round(bin2/bin4,0))

        #Get number of SNPs in each window
        x = 0
        countlistx = []
        countlisty = []
        count = 0
        for thing in bin:
            if x*bin3 <= thing < (x+1)*bin3:
                count+=1
                continue
            else:
                countlisty.append(count/bin3)
                countlistx.append((int((x+1)*bin3)+(int(x)*bin3))/2)
                density.append([chr,int((x)*bin3),int((x+1)*bin3),count/bin3])
                x+=1
                count = 0

    outfile3 = os.path.join(outfolder,os.path.basename(invcf)[:-4]+"_snpdensity.txt")
    head = ["Chr","Start","End","SNP Density"]
    with open(outfile3,'w+') as out_sd:
        writer = csv.writer(out_sd, delimiter="\t")
        writer.writerow(head)
        for row in density:
            writer.writerow(row)
    out_sd.close()

    print("\tSaved as",outfile3)

    return(density)

def frequgraph(recombrates, intxt, chrs, outfolder, numsnps, length, centromeres=None, density=None, missing=None):

    print("\n\tPlotting recombination rates")

    nrows = len(chrs)
    ysize = nrows*2

    fig, ax = plt.subplots(figsize = (7, ysize), sharex='col', sharey='row')
    plt.axis('off')
    fig.tight_layout()
    n=1
    groups = recombrates.Group.unique()

    for chr in chrs:
        ax2 = fig.add_subplot(nrows,1,n)
        for group in groups:
            rr2 = recombrates[recombrates['Chr'] == chr]
            rr2 = rr2[rr2['Group'] == group]
            rates = rr2['Recombination Rate'].tolist()
            positions = rr2['End'].tolist()
            label = group
            ax2.plot(positions,rates,label=label,linewidth=0.7)

        ax2.set_ylabel("Crossovers / bp",size=8)
        handles, labels = ax2.get_legend_handles_labels()
        if centromeres is not None:
            cent = centromeres[centromeres['Chr'] == chr]
            for index, row in cent.iterrows():
                ax2.axvspan(row['Start'],row['End'],facecolor='yellow',alpha=0.5)
            patch = mpatches.Patch(color='yellow', label='Centromere')
            handles.append(patch)

        if missing is not None:
            missdf = missing[missing['Chr'] == chr]
            pos = missdf['Pos'].tolist()
            missingness = missdf['Missingness']/missdf['Pos'].tolist()
            ax4 = ax2.twinx()
            ax4.spines['right'].set_position(('axes',1.15))
            ax4.set_frame_on(True)
            ax4.patch.set_visible(False)
            for sp in ax4.spines.values():
                sp.set_visible(False)
            ax4.spines['right'].set_visible(True)
            ax4.plot(pos,missingness,label='Missingness',color='gray',linestyle=':')
            ax4.set_ylabel("Missingness                 ")
            ax4.ticklabel_format(axis='y',style='sci',scilimits=(0,0),useOffset=False,useLocale=True)
            handles3, labels3 = ax4.get_legend_handles_labels()
            handles.extend(handles3)

        if density is not None:
            dens = density[density['Chr'] == chr]
            xlist = dens['End'].tolist()
            ylist = dens['SNP Density'].tolist()
            ax3=ax2.twinx()
            ax3.plot(xlist,ylist,label='Density',color='pink', linestyle=':',linewidth=0.7)
            ax3.set_ylabel("SNP Density",size=8)
            ax3.tick_params(axis='y',labelsize=7)
            ax3.yaxis.offsetText.set_fontsize(7)
            handles2, labels2 = ax3.get_legend_handles_labels()
            handles.extend(handles2)

        if n == 21:
            ax2.set_xlabel('Position',size=8)
        ax2.ticklabel_format(axis='both',style='sci',scilimits=(0,0),useOffset=False,useLocale=True)
        ax2.yaxis.offsetText.set_fontsize(7)
        ax2.xaxis.offsetText.set_fontsize(7)

        if n == 1:
            plt.legend(handles=handles, loc='upper center', ncol=7, prop={'size': 5})
        ax2.tick_params(axis='y',labelsize=7)
        ax2.tick_params(axis='x',labelsize=7)
        ax2.set_title(chr,fontsize=9)
        n+=1

    outfile2 = os.path.join(outfolder,os.path.basename(intxt)[:-4]+"_recombinationrates.png")
    plt.tight_layout(h_pad=0.1)
    plt.savefig(outfile2, dpi=600,bbox_inches='tight')
    print("\tSaved as",outfile2)

def main():
    print("recomb_rates.py:")
    par()

if __name__=="__main__":
    main()
